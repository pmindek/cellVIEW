#include "../Helper.cginc"

#pragma kernel ProteinFillBatchBuffer

#define MAX_SPHERE_COUNT_PER_BATCH 4096

uniform	float _Scale;
uniform int _EnableLod;
uniform	int _NumLevels;
uniform	int _NumInstances;
uniform float4 _CameraForward;
uniform float4 _CameraPosition;

uniform	int _CullFlagFilter;
uniform int _EnableCrossSection;
uniform float4 _CrossSectionPlane;
uniform float4 _FrustrumPlanes[6]; 

uniform	StructuredBuffer<int> _ProteinAtomCount;
uniform	StructuredBuffer<int> _ProteinAtomStart;
uniform	StructuredBuffer<int> _ProteinClusterCount;
uniform	StructuredBuffer<int> _ProteinClusterStart;

uniform	StructuredBuffer<int> _ProteinVisibilityFlag;
uniform StructuredBuffer<int> _ProteinInstanceCullFlags;
	
uniform StructuredBuffer<float4> _LodLevelsInfos;	
uniform	StructuredBuffer<float4> _ProteinInstanceInfo;
uniform	StructuredBuffer<float4> _ProteinInstancePositions;	
uniform AppendStructuredBuffer<int4> _ProteinSphereBatchInfos;


// Cutaways
uniform int _NumCuts;
uniform StructuredBuffer<float4> _CutInfos;	
uniform	StructuredBuffer<float4> _CutScales;
uniform	StructuredBuffer<float4> _CutPositions;	
uniform StructuredBuffer<float4> _CutRotations;

float pointPlaneSignedDistance(float3 p, float3 v0, float3 v1, float3 v2)
{
    float3 normal = normalize(cross(v1 - v0, v2 - v0));

    float3 t = (p - v0);
    return dot(normal, t);
}

bool isPointBehindPlane(float3 p, float3 v0, float3 v1, float3 v2)
{
    float3 normal = normalize(cross(v1 - v0, v2 - v0));

    float3 t = (p - v0);
    return dot(normal, t) < 0.0;
}

float rand(in int id)
{
	float2 uv = normalize(float2(id, id * 3543543));
    float2 noise = frac(sin(dot(uv, float2(12.9898,78.233)*2.0)) * 43758.5453);
    return abs(noise.x + noise.y) * 0.5;
}


[numthreads(1,1,1)]
void ProteinFillBatchBuffer (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= (uint)_NumInstances) return;
			
	float4 infos = _ProteinInstanceInfo[id.x];
	float4 sphere = _ProteinInstancePositions[id.x] * _Scale;
		
	int cullFlag = _ProteinInstanceCullFlags[id.x];
	bool frustrumTest = SphereFrustrumTest(_FrustrumPlanes, sphere);
	bool crossSectionTest = _EnableCrossSection && SpherePlaneTest(_CrossSectionPlane, float4(sphere.xyz, 0));
		
	// if instance is culled return
	if(_CullFlagFilter == -1 && cullFlag == 0) return;	
	if(_CullFlagFilter != -1 && cullFlag != _CullFlagFilter) return;
	if(frustrumTest || crossSectionTest || _ProteinVisibilityFlag[infos.x] == 0) return;
				
	int lodLevel = 0;		
	float cameraDistance = dot(sphere.xyz - _CameraPosition.xyz, _CameraForward.xyz);
		
	// Compute lod level from lod infos
	for(int i = 0; i < _NumLevels; i++) { lodLevel = (cameraDistance < _LodLevelsInfos[i].x) ? lodLevel : i+1; }	

	lodLevel = _EnableLod == 0 ? 0 : lodLevel;
	int clusterLevel = max(lodLevel - 1, 0);	
		
	// Find the count / start index of the protein
	int sphereCount = (lodLevel == 0) ? _ProteinAtomCount[infos.x] : _ProteinClusterCount[infos.x * _NumLevels + clusterLevel];
	int sphereStart = (lodLevel == 0) ? _ProteinAtomStart[infos.x] : _ProteinClusterStart[infos.x * _NumLevels + clusterLevel];

	// Find the number of batches for this protein
	int numBatches = ceil((float)sphereCount / (float)MAX_SPHERE_COUNT_PER_BATCH);	
	int sphereCountPerBatch = ceil(float(sphereCount) / float(numBatches));

	int batchStart = 0;
	int batchCount = sphereCountPerBatch;		
    
	////cutaways

	///*if (sphere.x > 0.0 && sphere.y > 0.0)
	//	return;*/

	//for (int j = 0; j < _NumCuts; j++)
	//{
	//	int _ = _CutFirstVertexIndexes[j];

	//	//plane
	//	if (_CutTypes[j] == 0)
	//	{
	//		float dist = pointPlaneSignedDistance(sphere, _CutVertices[_ + 0].xyz, _CutVertices[_ + 1].xyz, _CutVertices[_ + 2].xyz);
	//		float size = length(_CutVertices[_ + 0].xyz - _CutVertices[_ + 1].xyz);
	//		float normalDist = dist / size;
	//		float nd = -normalDist * 6.0;

	//		if (normalDist < 0.0 && rand(id.x) * 0.9 <= pow(nd, 0.2))
	//			return;

	//		/*if (isPointBehindPlane(sphere, _CutVertices[_ + 0].xyz, _CutVertices[_ + 1].xyz, _CutVertices[_ + 2].xyz))
	//		{
	//			if (rand(id.x) < 0.99)
	//				return;
	//		}*/
	//	}

	//	//sphere
	//	else if (_CutTypes[j] == 1)
	//	{
	//		if (length(_CutVertices[_].xyz - sphere) < _CutVertices[_].w)
	//		{
	//			return;
	//		}
	//	}

	//	//cube
	//	else if (_CutTypes[j] == 2)
	//	{
	//		if (isPointBehindPlane(sphere, _CutVertices[_ + 6].xyz, _CutVertices[_ + 0].xyz, _CutVertices[_ + 1].xyz) && //bottom
	//			isPointBehindPlane(sphere, _CutVertices[_ + 3].xyz, _CutVertices[_ + 2].xyz, _CutVertices[_ + 4].xyz) && //top
	//			isPointBehindPlane(sphere, _CutVertices[_ + 1].xyz, _CutVertices[_ + 3].xyz, _CutVertices[_ + 5].xyz) && //left
	//			isPointBehindPlane(sphere, _CutVertices[_ + 0].xyz, _CutVertices[_ + 6].xyz, _CutVertices[_ + 4].xyz) && //right
	//			isPointBehindPlane(sphere, _CutVertices[_ + 1].xyz, _CutVertices[_ + 0].xyz, _CutVertices[_ + 2].xyz) && //front
	//			isPointBehindPlane(sphere, _CutVertices[_ + 6].xyz, _CutVertices[_ + 7].xyz, _CutVertices[_ + 5].xyz))  //back
	//		{
	//			return;
	//		}
	//	}
	//}

	for(int j = 0; j < numBatches; j++)
	{
		batchCount = min(batchStart + sphereCountPerBatch, sphereCount) - batchStart;			
		_ProteinSphereBatchInfos.Append(int4(id.x, lodLevel, batchCount, sphereStart + batchStart));
		batchStart += batchCount;
	}		
}