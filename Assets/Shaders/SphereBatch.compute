#include "Helper.cginc"

#pragma kernel ProteinFillBatchBuffer
#pragma kernel ProteinFillBatchBuffer2

#define MAX_SPHERE_COUNT_PER_BATCH 4096

uniform float _Scale;
uniform int _EnableLod;
uniform	int _NumLevels;
uniform	int _NumInstances;
uniform float4 _CameraForward;
uniform float4 _CameraPosition;

uniform	int _CullingFilter;
uniform float4 _FrustrumPlanes[6]; 

uniform	StructuredBuffer<float> _ProteinRadii;
uniform	StructuredBuffer<int> _ProteinVisibilityFlag;

uniform	StructuredBuffer<int> _ProteinAtomCount;
uniform	StructuredBuffer<int> _ProteinAtomStart;
uniform	StructuredBuffer<int> _ProteinClusterCount;
uniform	StructuredBuffer<int> _ProteinClusterStart;
	
uniform StructuredBuffer<float4> _LodLevelsInfos;	
uniform	StructuredBuffer<float4> _ProteinInstanceInfo;
uniform StructuredBuffer<int> _ProteinInstanceCullFlags;
uniform	StructuredBuffer<float4> _ProteinInstancePositions;	
uniform AppendStructuredBuffer<int4> _ProteinSphereBatchInfos;

uniform StructuredBuffer<int> _ProteinInstanceOcclusionFlags;
uniform StructuredBuffer<int> _ProteinInstanceVisibilityFlags;

// Cutaways
uniform int _NumCutObjects;
uniform StructuredBuffer<float4> _CutInfos;	
uniform	StructuredBuffer<float4> _CutScales;
uniform	StructuredBuffer<float4> _CutPositions;	
uniform StructuredBuffer<float4> _CutRotations;
uniform StructuredBuffer<int> _ProteinCutFilters;
uniform StructuredBuffer<int> _HistogramProteinTypes;
RWStructuredBuffer<int> _HistogramStatistics;

uniform Texture2D<float4> noiseTexture;
uniform float noiseTextureW;
uniform float noiseTextureH;

/*float CutAwayTest(float4 sphere, int proteinType)
{
    bool cut = false;
    for (int i = 0; i < _NumCutObjects; i++)
    {
        int proteinCutFilter = _ProteinCutFilters[proteinType * _NumCutObjects + i];

        if (proteinCutFilter == 1)
        {
            float4 info = _CutInfos[i];
            float3 position = _CutPositions[i].xyz;
            float4 rotation = _CutRotations[i];
            float3 scale = _CutScales[i].xyz;
           
            if (info.x == 0)  //plane
            {
                float3 normal = QuaternionTransform(rotation, float3(0, 1, 0));
                float4 plane = ComputePlane(normal, position);
                bool test = SpherePlaneTest(plane, float4(sphere.xyz, 0));
                if (test) return true;
            }
            else if (info.x == 1)  //sphere
            {
                bool test = SphereSphereTest(float4(position, scale.x * 0.5), float4(sphere.xyz, 0));
                if (test) return true;
            }
            else if (info.x == 2)  //cube
            {
                bool test = SphereCubeTest(position, rotation, scale * 0.5, float4(sphere.xyz, 0));
                if (test) return true;
            }
        }
    }

    return cut;
}*/

float rand(in int id)
{
	float2 uv = normalize(float2(id, id * 3543543));

	uint2 uvi = uint2(id % noiseTextureW, id / noiseTextureH);

	//float2 noise = noiseTexture[uvi].x;
    float2 noise = frac(sin(dot(uv, float2(12.9898,78.233)*2.0)) * 43758.5453) * noiseTexture[uvi].xy;
    return abs(noise.x + noise.y) * 0.5;
}

float CutAwayTest(float4 sphere, int proteinType, int id)
{
    bool cut = false;
    for (int i = 0; i < _NumCutObjects; i++)
    {
        int proteinCutFilter = _ProteinCutFilters[proteinType * _NumCutObjects + i];
		//int proteinCutFilter = _HistogramProteinTypes[proteinType * _NumCutObjects + i];

        if (proteinCutFilter == 1)
        {
            float4 info = _CutInfos[i];
            float3 position = _CutPositions[i].xyz;
            float4 rotation = _CutRotations[i];
			float3 scale = _CutScales[i].xyz;

			float distance = 0.0;

            if (info.x == 0)
            {
                float3 normal = QuaternionTransform(rotation, float3(0, 1, 0));
                float4 plane = ComputePlane(normal, position);
                distance = SpherePlaneSD(plane, float4(sphere.xyz, 0));
            }
			else if (info.x == 1)
			{
				distance = SphereSphereSD(float4(position, scale.x * 0.5), float4(sphere.xyz, 0));
			}
			else if (info.x == 2)
			{
				distance = SphereCubeSD(position, rotation, scale * 0.50, float4(sphere.xyz, 0));
			}
			else if (info.x == 3)
			{
				distance = SphereCylinderSD(position, rotation, scale * 0.50, float4(sphere.xyz, 0));
			}
			else if (info.x == 4)
			{
				distance = SphereInfiniteConeSD(position, rotation, scale * 0.5, float4(sphere.xyz, 0));
			}

			bool test = distance <= 0.0;
			//bool fuzzTest = rand(id) * 3.0 * info.y <= pow(abs(distance), info.z * 1.0);
			//bool fuzzTest = rand(id) < info.y;
			bool fuzzTest = true;
			bool adjustTest = true;
			bool adjustVisibilityTest = true;

			float adjust = -1.0 + info.y * 2.0;

			if (adjust > 0 && pow(rand(id), 0.5) < adjust)
			{
				adjustTest = false;
			}
			if (!test && adjust < 0 && pow(rand(id), 0.5) < -adjust)
			{
				test = true;
			}

            if (test && fuzzTest && adjustTest && adjustVisibilityTest) return true;

        }    

        //	//sphere
        //	else if (_CutTypes[j] == 1)
        //	{
        //		if (length(_CutVertices[_].xyz - sphere) < _CutVertices[_].w)
        //		{
        //			return;
        //		}
        //	}

        //	//cube
        //	else if (_CutTypes[j] == 2)
        //	{
        //		if (isPointBehindPlane(sphere, _CutVertices[_ + 6].xyz, _CutVertices[_ + 0].xyz, _CutVertices[_ + 1].xyz) && //bottom
        //			isPointBehindPlane(sphere, _CutVertices[_ + 3].xyz, _CutVertices[_ + 2].xyz, _CutVertices[_ + 4].xyz) && //top
        //			isPointBehindPlane(sphere, _CutVertices[_ + 1].xyz, _CutVertices[_ + 3].xyz, _CutVertices[_ + 5].xyz) && //left
        //			isPointBehindPlane(sphere, _CutVertices[_ + 0].xyz, _CutVertices[_ + 6].xyz, _CutVertices[_ + 4].xyz) && //right
        //			isPointBehindPlane(sphere, _CutVertices[_ + 1].xyz, _CutVertices[_ + 0].xyz, _CutVertices[_ + 2].xyz) && //front
        //			isPointBehindPlane(sphere, _CutVertices[_ + 6].xyz, _CutVertices[_ + 7].xyz, _CutVertices[_ + 5].xyz))  //back
        //		{
        //			return;
        //		}
        //	}
    }

    return cut;
}



[numthreads(1,1,1)]
void ProteinFillBatchBuffer (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= (uint)_NumInstances) return;

    float4 infos = _ProteinInstanceInfo[id.x];	
	int cullFlag = _ProteinInstanceCullFlags[id.x];
	float radius = _ProteinRadii[infos.x] * _Scale;
	float3 pos = _ProteinInstancePositions[id.x].xyz * _Scale;	
	float4 sphere = float4(pos, radius);


	//if(infos.x != 4) return;
    //if(_ProteinInstanceOcclusionFlags[id.x] != 0) return;
	//if(_ProteinVisibilityFlag[id.x] == 0) return;

	//if (infos.x != 4)
	/*if (_ProteinInstanceVisibilityFlags[id.x] != 0)
	return;*/
		
	bool frustrumTest = SphereFrustrumTest(_FrustrumPlanes, sphere);
	bool cutAwayTest = CutAwayTest(float4(sphere.xyz, 0), infos.x, id.x);


	for (int i = 0; i < _NumCutObjects; i++)
    {
		int h = _HistogramProteinTypes[infos.x * _NumCutObjects + i];
		int v = _ProteinInstanceOcclusionFlags[id.x];

		if (h != 0)
		{
			InterlockedAdd(_HistogramStatistics[1], 1); //count all
			if (cutAwayTest)
			{
				InterlockedAdd(_HistogramStatistics[0], 1); //count cut aways
			}

			else if (v != 0)
			{
				InterlockedAdd(_HistogramStatistics[2], 1);
			}
		}
	}


    // if instance is culled return
    if(_CullingFilter == -1 && cullFlag == 0) return;
    if (_CullingFilter != -1 && cullFlag != _CullingFilter) return;
    if (frustrumTest || cutAwayTest /*|| _ProteinVisibilityFlag[infos.x] == 0*/) return;

    int lodLevel = 0;		
	float cameraDistance = dot(sphere.xyz - _CameraPosition.xyz, _CameraForward.xyz);
		
	// Compute lod level from lod infos
	for(int i = 0; i < _NumLevels; i++) { lodLevel = (cameraDistance < _LodLevelsInfos[i].x) ? lodLevel : i+1; }	

	lodLevel = _EnableLod == 0 ? 0 : lodLevel;
	int clusterLevel = max(lodLevel - 1, 0);	
		
	// Find the count / start index of the protein
	int sphereCount = (lodLevel == 0) ? _ProteinAtomCount[infos.x] : _ProteinClusterCount[infos.x * _NumLevels + clusterLevel];
	int sphereStart = (lodLevel == 0) ? _ProteinAtomStart[infos.x] : _ProteinClusterStart[infos.x * _NumLevels + clusterLevel];

	// Find the number of batches for this protein
	int numBatches = ceil((float)sphereCount / (float)MAX_SPHERE_COUNT_PER_BATCH);	
	int sphereCountPerBatch = ceil(float(sphereCount) / float(numBatches));

	int batchStart = 0;
	int batchCount = sphereCountPerBatch;

    for (int j = 0; j < numBatches; j++)
	{
		batchCount = min(batchStart + sphereCountPerBatch, sphereCount) - batchStart;			
		_ProteinSphereBatchInfos.Append(int4(id.x, lodLevel, batchCount, sphereStart + batchStart));
		batchStart += batchCount;
	}		
}

//*****//

uniform int _ProteinType;
uniform AppendStructuredBuffer<int4> _OcclusionQueriesBatchSpheres;

[numthreads(64, 1, 1)]
void ProteinFillBatchBuffer2(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_NumInstances) return;

    float4 infos = _ProteinInstanceInfo[id.x];
    /*if (_ProteinType > 0 && infos.x != _ProteinType -1) return;
    if (_ProteinType < 0 && infos.x == _ProteinType + 1) return;*/

	bool doReturn = false;
	for (int i = 0; i < _NumCutObjects; i++)
    {
		 if (_ProteinType > 0 && _ProteinCutFilters[infos.x * _NumCutObjects + i] == 1)
			return;
		 if (_ProteinType < 0 && _ProteinCutFilters[infos.x * _NumCutObjects + i] == 0)
		 {
			doReturn = true;
		 }
	}

	if (doReturn)
		return;

	//return;

    //int cullFlag = _ProteinInstanceCullFlags[id.x];
    //if (_CullingFilter == -1 && cullFlag == 0) return;
    //if (_CullingFilter != -1 && cullFlag != _CullingFilter) return;

    //float radius = _ProteinRadii[infos.x] * _Scale;
    //float3 pos = _ProteinInstancePositions[id.x].xyz * _Scale;
    //float4 sphere = float4(pos, radius);

    //bool frustrumTest = SphereFrustrumTest(_FrustrumPlanes, sphere);
    //if (frustrumTest) return;

    //bool cutAwayTest = CutAwayTest(float4(sphere.xyz, 0), infos.x, id.x);
    //if (cutAwayTest) return;

    _OcclusionQueriesBatchSpheres.Append(int4(id.x, 0, 0, 0));

	_HistogramStatistics[0] = 0;
	_HistogramStatistics[1] = 0;
	_HistogramStatistics[2] = 0;
	_HistogramStatistics[3] = 0;
}