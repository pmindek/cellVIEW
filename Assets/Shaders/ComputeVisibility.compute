// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ClearVisibilityFlags
#pragma kernel ComputeVisibility
#pragma kernel ClearHistograms
#pragma kernel DicardOccludingInstances

Texture2D<int> _ItemBuffer;
RWStructuredBuffer<int> _FlagBuffer;

[numthreads(64, 1, 1)]
void ClearVisibilityFlags(uint3 id : SV_DispatchThreadID)
{
    _FlagBuffer[id.x] = 0;
}

[numthreads(8, 8, 1)]
void ComputeVisibility(uint3 id : SV_DispatchThreadID)
{
    int idx = _ItemBuffer[id.xy];
    if (idx >= 0) _FlagBuffer[idx] = 1;
}

//histograms
struct HistStruct
{
	int parent; //also write data to this id, unless it is < 0

	int all;
	int cutaway;
	int occluding;
	int visible;

	int pad0;
	int pad1;
	int pad2;
};

RWStructuredBuffer<HistStruct> _Histograms;

[numthreads(64, 1, 1)]
void ClearHistograms(uint3 id : SV_DispatchThreadID)
{
    HistStruct clearHist = _Histograms[id.x];
	clearHist.all = 0;
	clearHist.cutaway = 0;
	clearHist.occluding = 0;
	clearHist.visible = 0;

    _Histograms[id.x] = clearHist;
}

int _CutObjectId;
int _ConsumeRestoreState;
StructuredBuffer<int> _HistogramsLookup;
StructuredBuffer<float> _ProteinOcclusionValues;

RWStructuredBuffer<float4> _ProteinInstanceInfo;
RWStructuredBuffer<int> _ProteinInstanceCullFlags;
RWStructuredBuffer<int> _ProteinInstanceOcclusionFlags;

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float rand(uint value)
{
	return float(wang_hash(value)) * (1.0 / 4294967296.0);
}

[numthreads(64, 1, 1)]
void DicardOccludingInstances(uint3 id : SV_DispatchThreadID)
{	
	float4 info = _ProteinInstanceInfo[id.x];
	float probability = _ProteinOcclusionValues[info.x];

	if(_ConsumeRestoreState == 2 && info.w == _CutObjectId)
	{
		_ProteinInstanceInfo[id.x].w = 0;
	}

	if(_ProteinInstanceOcclusionFlags[id.x] == 1)
	{
		if(rand(id.x) < probability)
		{
			_ProteinInstanceCullFlags[id.x] = 1;	
			int addWhere = _HistogramsLookup[info.x];
			InterlockedAdd(_Histograms[addWhere].cutaway, 1);

			if(_ConsumeRestoreState == 1)
			{
				_ProteinInstanceInfo[id.x].w = _CutObjectId;
			}
		}

		_ProteinInstanceOcclusionFlags[id.x] = 0;
	}     
}
